# t1ha2_128

t1ha2_128 is the 128-bit version of t1ha2, providing extended hash length for applications requiring higher collision resistance while maintaining the performance characteristics of t1ha2.

## Signatures

- `t1ha2_128(text)` → `bigint[]`
- `t1ha2_128(text, bigint)` → `bigint[]`
- `t1ha2_128(bytea)` → `bigint[]`
- `t1ha2_128(bytea, bigint)` → `bigint[]`
- `t1ha2_128(integer)` → `bigint[]`
- `t1ha2_128(integer, bigint)` → `bigint[]`

## Parameters

- First parameter: Input data to hash (`text`, `bytea`, or `integer`)
- Second parameter (optional): Seed value (default: 0)

## Return Value

Returns an array of two `bigint` values representing the 128-bit hash:
- `[1]`: First 64 bits of the hash
- `[2]`: Second 64 bits of the hash

## Examples

```sql
-- Hash text with default seed
SELECT t1ha2_128('hello world');
-- Result: {first_64_bits, second_64_bits}

-- Hash text with custom seed
SELECT t1ha2_128('hello world', 42);
-- Result: High-quality 128-bit t1ha2 hash with custom seed

-- Hash bytea data
SELECT t1ha2_128('hello world'::bytea);
-- Result: High-quality 128-bit t1ha2 hash of bytea data

-- Hash integer values
SELECT t1ha2_128(12345);
-- Result: High-quality 128-bit t1ha2 hash of integer

-- Access individual parts of the 128-bit hash
SELECT 
    (t1ha2_128('hello world'))[1] AS first_64_bits,
    (t1ha2_128('hello world'))[2] AS second_64_bits;
```

## Use Cases

- Strong fingerprinting with collision resistance
- 128-bit hash table implementations
- Content addressing requiring extended hash length
- Data deduplication with reduced collision probability